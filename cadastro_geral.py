# -*- coding: utf-8 -*-
"""cadastro_geral.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I8AUYg6rGNdOQtSOJ4fUNlWLvuGUNA68

# Cadastro Geral

Atualmente há duas lista de cadastro geral no Ponto do Bem. O objetivo desse programa é conciliar os dados das duas em uma planilha só. Ademais, userei VBA para corresponder dados novos em futuras atualizaçôes.
"""

import pandas as pd
import numpy as np

geral_oficial = pd.read_csv("/content/CADASTRO_GERAL.csv", parse_dates=True)
geral_nao_oficial = pd.read_csv("/content/Cadastro_Geral_Nao_oficial.csv", parse_dates=True)

"""## Visualizações"""

geral_nao_oficial.tail()

geral_oficial.tail()

"""Vemos que a lista oficial tem mais dados do que a não oficial."""

geral_nao_oficial.shape, geral_oficial.shape

geral_oficial.dtypes

"""A lista oficial foi toda reconhecida como string, exceto a coluna da Cesta 3. """

geral_nao_oficial.dtypes

"""## Modificando e validando dados

### Excluindo e Renomeando colunas
"""

geral_nao_oficial = geral_nao_oficial.drop("Liberado?", axis = 1) # Exluiu a coluna Liberado?
geral_nao_oficial = geral_nao_oficial.drop("Nº", axis = 1) # Exclui a coluna Nº

"""Para melhor usar o join/merge/combine faremos as colunas nas duas planilhas terem o mesmo nome quando necessárias."""

nomes = {"Remédios / Roupas": "Pedidos de Roupa/Remédio", "Tipo de Auxílio": "Recebe Auxílio?",
         "(R$)": "Renda mensal", "DATA DA PLANILHA": "Data de entrada", "Data de Atualização": "Última atualização"}

geral_nao_oficial.rename(nomes, axis = 1, inplace=True)

geral_nao_oficial.head()

geral_oficial.rename({"Nº+": "Nº"}, axis = 1, inplace= True)

"""### Estruturando a Coluna "CPF""""

# Essa função enviar cada valor para ser checado
def separacao(data_serie):
  num = 0

  for i in range(len(data_serie)):
    try:
      if math.isnan(data_serie[i]):
        # Se o valor for NaN ele pula
        continue
        
    except TypeError:
        pass

    if type(data_serie[i]) is list:
      # Se for uma lista, junta os valores ao converte-los para string
      data_serie[i] = [str(x) for x in data_serie[i]]
      data_serie[i] = "".join(data_serie[i])

    if data_serie[i].startswith("ID:") or data_serie[i].startswith("RG") or data_serie[i].startswith("Ca"):
      # Se começa com "ID:" ou "RG" é ignorado
      continue

    if data_serie[i].startswith("?"):
      # se o valor for "?" é trocado por NaN
      data_serie[i] = np.nan
      continue

    valores = cpf(data_serie[i])
    num += 1

    if num % 10 == 0:
      # Printa a cada 10 CPF
      print(data_serie[i], valores[0], "index =", i)

    if valores[1] == False:
      data_serie[i] = valores[0]
  
  return data_serie

import math
# Essa função checará se o CPF está no formato XXX.XXX.XXX-XX
def cpf(valor):
  
  cpf = []
  valor = list(valor.strip()) # Transforma em uma lista
      
  for i in range(len(valor)):
    # Começa a verificar do ultimo ao primeiro
        
    if valor[i].isdigit():
      # Se o valor for digito

      cpf.append(str(valor[i]))
    
  while len(cpf) < 11:
    # se a lista for menor que 11 será adicionado um 0 até completar 11 digito

    cpf.insert(0, "0")
  
  # Insere os caracteres nas posições específicas
  cpf.insert(3, ".") 
  cpf.insert(7, ".")
  cpf.insert(11, "-")

  return ["".join(cpf), False]

# Passando a serie da Coluna CPF
coluna_cpf = geral_nao_oficial.loc[:, ("CPF")]
coluna_cpf = separacao(coluna_cpf)

coluna_cpf_oficial = separacao(geral_oficial.loc[:, ("CPF")])

"""Agora que padronizamos o CPF, iremos colocar no DataFrame."""

geral_nao_oficial["CPF"] = coluna_cpf
geral_oficial["CPF"] = coluna_cpf_oficial

geral_nao_oficial["CPF"].head()

"""### Tirando todos os dados "?????""""

lista = ["?", "??", "???", "????", "?????"]

geral_nao_oficial.replace(lista, np.nan, inplace= True)
geral_oficial.replace(lista, np.nan, inplace= True)

"""### Excluindo linhas vazias"""

geral_nao_oficial["Nome"][1300:]

geral_nao_oficial.drop([1367], inplace = True)

geral_oficial["Nome"][1500:]

index = [1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517,
         1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529,
         1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540]

geral_oficial.drop(index, inplace = True)

"""## Juntando as duas planilhas"""

Colunas = ["CPF", "Nome", "Telefone", "Data de entrada"]

mergido = pd.merge(geral_nao_oficial, geral_oficial, on = Colunas, how="outer")

geral_nao_oficial.shape, geral_oficial.shape, mergido.shape

mergido.tail()

combinado = geral_oficial.combine_first(geral_nao_oficial)

combinado.shape

combinado.head()

"""Vemos que usando o ***combine()*** é a melhor opção, já que ele combina os valores faltantes quando as duas colunas tem o mesmo nome. No total temos o mesmo número de colunas e linhas que a planilha Geral_Oficial. Apesar disso, as colunas ficaram embaralhadas, nada que um ordernação não resolva.

### Reordenando as colunas
"""

cols = list(geral_oficial.columns.values)
cols

combinado = combinado[cols]
combinado

"""### Atualizando a lista combinada"""

# Essa função passa os dados para checagem
def checa(data_frame):

  for i in range(data_frame.shape[0]):

    if data_frame["EV/AB/PRAÇA"][i] in ["Praça", "praça", "Praca", "praca", "PRAÇA", "PRACA"]:
      # Se a pessoa é da Praça checa o valor na coluna Cesta a

      try:
        if math.isnan(data_frame["CESTA 1"][i]):
          # Se a Cesta 1 for NaN 

          try:
            if math.isnan(data_frame["Data de entrada"][i]):
              # Checa se a data de entrada é nula
              continue

          except TypeError:
            data_frame["CESTA 1"][i] = data_frame["Data de entrada"][i]

      except TypeError:
        continue

  return data_frame

geral_oficial = checa(combinado)

geral_oficial

"""## Salvando a planilha"""

geral_oficial.to_excel("Cadastro_Geral.xlsx", sheet_name="Cadastro", index=False)

